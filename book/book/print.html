<!DOCTYPE HTML>
<html lang="en" class="frappe sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fx.go</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./theme/catppuccin.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "frappe";
            const default_dark_theme = "mocha";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('frappe')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="latte">Latte</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="frappe">Frappe</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="macchiato">Macchiato</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mocha">Mocha</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Fx.go</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>An Algebraic Effects System for Golang.</p>
<div class="warning">
Fx.go is currently experimental. 
<p>API surface is <em>very much</em> in flux and evolving.</p>
<p>New effects will be added as they are discovered to be useful in the golang ecosystem.</p>
</div>
<h3 id="how-are-algebraic-effects-useful"><a class="header" href="#how-are-algebraic-effects-useful">How are Algebraic Effects useful?</a></h3>
<p>Algebraic Effects are useful because they allow programs to
be expressed not only in terms of what kind of value they can
compute but also on what possible side-effects or external resources will such a computation require.</p>
<p>By using Effect Handlers, the interpretation of how an effect is performed is independent of the program description. This means that a single program description can be interpreted in different ways. For example, using a <em>test-handler</em> that mocks request to external services, or using a <em>live-handler</em> that actually performs such requests.</p>
<p>If you want to read more about different language implementations and theory behind effects, read the <a href="https://github.com/yallop/effects-bibliography">effects-bibliography</a>.</p>
<p><code>Fx.go</code> is inspired by the following two implementations, and uses a similar notion of the <em>Handler</em>, <em>Ability</em>, and <em>Effect</em> concepts:</p>
<ul>
<li><a href="https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/">Unison Abilities</a></li>
<li><a href="https://github.com/getkyo/kyo/">Kyo (Scala3)</a> - special thanks to <a href="https://x.com/fbrasisil">@fbrasisil</a>, Kyo's author who kindly provided a minimal kyo-core that helped <a href="https://x.com/oeiuwq">me</a> understand algebraic effect systems and inspired this library.</li>
</ul>
<p>However, <code>Fx.go</code> has a different surface API since we are trying to provide the best dev-experience for Golang programmers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts-tour"><a class="header" href="#concepts-tour">Concepts Tour</a></h1>
<p>This section will try to introduce you to the concepts of
<em>Effects</em>, <em>Abilities</em> and <em>Handlers</em> as present in <code>Fx.go</code>.</p>
<p>No knowledge or previous experience with other effect sytems
is expected. We will try to explain things by
working out from simple concepts to more interesting ones.</p>
<h2 id="effects"><a class="header" href="#effects">Effects</a></h2>
<p>An <em>Effect</em> ( <code>Fx[S, V]</code> read: <code>V</code> provided <code>S</code> ) is the <em>description</em> of a program that computes <code>V</code>, <em>provided</em> that the requirement <code>S</code> is present, so that the computation of <code>V</code> can be performed.</p>
<p>Since effects are <em>description</em>s of programs, they compute nothing nor produce side-effects until they are finally evaluated, once all their requirements are at met.</p>
<p>Some people also use the <em>recipe</em> analogy for effects: you first have a precise description of each step it takes to cook something, along with a list of the requirements for it (the ingredients and utencils you will use) and once you have them all, you can actually perform the recipe.</p>
<h2 id="abilities"><a class="header" href="#abilities">Abilities</a></h2>
<p>In <code>Fx[S, V]</code>, <code>S</code> is said to be the <em>Ability</em> (sometimes also referred as the <em>set</em> of <em>Abilities</em>, <em>Capabilities</em> or <em>Requirements</em>) that are needed for computing <code>V</code>.</p>
<p>Abilities describe the external resources that would be needed, as well as the <em>side-effects</em> that are possible while computing <code>V</code>.</p>
<p>Examples of such Abilities are:</p>
<ul>
<li>network abilities (eg, performing http requests)</li>
<li>console abilities (eg, printing to the terminal or reading user input)</li>
<li>non-deterministic abilities (eg, generating random numbers or coin-flips)</li>
<li>resource handling (eg, disciplined acquire/use/release of shared/limited resources)</li>
<li>exception handling (eg, interruption/resumption and finalizers)</li>
<li>anything else that interacts with the world outside of the program.</li>
</ul>
<h2 id="handlers"><a class="header" href="#handlers">Handlers</a></h2>
<p>A <em>Handler</em> for the <code>S</code> ability is a particular <em>interpretation</em> of what <code>S</code> means.</p>
<p>It is the Handler of <code>S</code> the only <em>side-effectful</em> portion of your programs. It is possible and quite common to have different handlers (interpretations) for the same Ability, and each Handler  decides <em>how/when</em> to perform world-modifying <em>side-effects</em>.</p>
<p>For example, for an <em>http-request</em> ability you can have a <em>test-handler</em> that just mock responses to fixed values so that you can easily assert on known values on your tests. You could also have a <em>live-handler</em> that actually performs requests via the network for production runs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-effects-on-fxgo"><a class="header" href="#basic-effects-on-fxgo">Basic Effects on <code>Fx.go</code></a></h1>
<p>This section expands on <a href="concepts.html">Concepts</a> and shows how they relate to the <code>Fx.go</code> API, as well as providing a basic intuition on Effect requirements and evaluation.</p>
<h2 id="purev-immediate-effects"><a class="header" href="#purev-immediate-effects"><code>Pure[V]</code>: Immediate Effects</a></h2>
<p>The most basic of all possible effects are <em>Immediate</em> effects. These are effects of type <code>Fx[Nil, V]</code>, meaning that they have no ability requirements (<code>Nil</code>) and evaluate to a value (<code>V</code>).</p>
<p>Immediate effects are created using the <code>Pure(*V) Fx[Nil, V]</code> function. The name <code>Pure</code> relates to the convential naming on effect systems for moving (lifting) a value <code>V</code> into the domain of <code>Fx</code>.</p>
<p>As you can see, <code>Pure(*V)</code> takes a pointer to an <em>existing</em> value <code>V</code>, that means that a pure effect just holds a pointer to an already known value instead of trying to compute it.</p>
<p>The pointer given to <code>Pure</code> can be retrieved by using <code>Eval(Fx[Nil, V]) *V</code>. Only effects that have no requirements (<code>Nil</code>) can be evaluated.</p>
<pre><code class="language-go">import ( fx "github.com/vic/fx.go" )

func PureExample() {
    v := "Hello World"
    // Code annotated with types for clarity
    var effect fx.Fx[fx.Nil, string] = fx.Pure(&amp;v)
    var result *string = fx.Eval(effect)
    assert(*result == v)
}
</code></pre>
<h2 id="fxs-v-pending-effects"><a class="header" href="#fxs-v-pending-effects"><code>Fx[S, V]</code>: Pending effects</a></h2>
<p>An effect <code>Fx[S, V]</code> where <code>S != Nil</code> is a pending effect that needs <code>S</code> to be <em>provided</em> for computing <code>V</code>.</p>
<p>The most basic pending computation is one you are already familiar with: <em>A function</em>.</p>
<p>In the following example, the function <code>LengthOfString(string) int</code> can be expressed as an Effect of type <code>Fx[string, int]</code>. Meaning that in order to have a value of <code>int</code> you need first to provide an <code>string</code> value:</p>
<pre><code class="language-go">func LengthOfString(s string) int {
    return len(s)
}

func FuncExample() {
    // Code annotated with types for clarity
    var effect fx.Fx[string, int] = fx.Func(LengthOfString)
    var requirement string = "Hello World"
    var provided fx.Fx[fx.Nil, int] = fx.Provide(effect, &amp;requirement)
    var result *int = fx.Eval(provided)
    assert(*result == len(requirement))
}
</code></pre>
<p>From the code above:</p>
<ul>
<li><code>Func(func (S) V)</code> produces a <em>pending</em> effect of type <code>Fx[S, V]</code>.</li>
<li><code>Provide(Fx[S, V], *S)</code> discharges the <code>S</code> requirement and returns <code>Fx[Nil, V]</code>.<br />
Note that <em>no computation</em> is performed in this step. <code>Fx[Nil, V]</code> is still a description of a program, and <code>V</code> has not been computed yet, nor any side-effect has been performed.</li>
<li><code>Eval(Fx[Nil, V])</code> will actually perform the computation of <code>V</code>, since all <code>non-Nil</code> requirements have already , the computation can be performed.been provided.</li>
</ul>
<p>These two are the most basic effects in <code>Fx.go</code>, and using them we have shown the essential <code>fx.Provide</code> and <code>fx.Eval</code> APIs.</p>
<p>More interesting effects will be presented as we explore the topics of Handlers and combinators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effect-requirements"><a class="header" href="#effect-requirements">Effect Requirements</a></h1>
<p>So far, we have seen that an effect <code>Fx[S, V]</code> can have <code>S</code> be <code>Nil</code> for effects that can be evaluated right away and non-<code>Nil</code> for those pending effects that still need to be provided some value.</p>
<p>In this chapter we will talk about Composite requirement types using the <code>And</code> type. And how different types of functions/effects can represent the very same computation. We also look at similarities with higher-order functions in functional-programming and how rotating or re-arranging effect requirements is indifferent in <code>Fx.go</code>. Finally, we show some the<code>And*</code> and <code>Provide*</code> combinators that can help you reshape your effect requirements.</p>
<h2 id="anda-b-composed-requirement-types"><a class="header" href="#anda-b-composed-requirement-types"><code>And[A, B]</code> composed Requirement Types</a></h2>
<p>Using the same "length of string" function from the previous chapters, we can describe it in different ways.</p>
<pre><code class="language-go">// This is an strange way of writing `func(string) int`.
// But this shape is used to understand the types bellow.
//
// Focus on what are the requirements needed to perform 
// a computation, more than the shape of the type.
//
// In particular, note that `Fx[Nil, V]` is like a `func() V`
func LenghtOfString(s string) func() int {
    return func() int { return len(s) }
}

type LenFn = func(string) Fx[Nil, int]
</code></pre>
<p>Note that all of the following types are equivalent, as they describe the very same requirements and result types:</p>
<ul>
<li><code>func(string) int</code></li>
<li><code>Fx[string, int]</code></li>
<li><code>func(string) func() int</code></li>
<li><code>func(string) Fx[Nil, int]</code></li>
<li><code>Fx[string, Fx[Nil, int]]</code></li>
<li><code>Fx[And[string, Nil], int]</code></li>
<li><code>Fx[And[Nil, string], int]</code></li>
</ul>
<p>The last three examples represent nested effects and are equivalent to functions of arity &gt; 1 or functions that return functions.</p>
<p><code>And[A, B]</code> is the requirement for both <code>A</code> and <code>B</code> abilities. Notice on the last two examples, that they have their components swapped, however, its important to note that in <code>Fx.go</code>, <em>the <em>order</em> of the abilities on the requirement does not matter</em> and can be freely swapped/joined/unjoined. More on this when we talk about <code>And*</code> combinators.</p>
<p>Also, note that <code>And[A, Nil]</code> is equivalent to just <code>A</code>. All of these types represent the same type of computation and an effect can be transformed to any of those types freely.</p>
<h2 id="1-arity-functions-as-effects"><a class="header" href="#1-arity-functions-as-effects"><code>&gt;1</code> arity functions as effects.</a></h2>
<p>Suppose you have a function that multiplies an string length by n.</p>
<pre><code class="language-go">func MulLen(s string, n int) int {
    return len(s) * n
}
</code></pre>
<p><code>MulLen</code> can be described by the following types:</p>
<ul>
<li><code>func(string, int) int</code></li>
<li><code>func(string) func(int) int</code></li>
<li><code>Fx[And[string, int], int]</code></li>
<li><code>Fx[string, Fx[int, int]]</code></li>
<li><code>Fx[int, Fx[string, int]]</code></li>
<li><code>Fx[And[int, string], int]</code></li>
</ul>
<p>An important thing to note is that in <code>Fx</code>, the <em>requirements are identified by their type</em> and not by their name, so they can be freely re-arranged or provided in any order. Note that <code>And[X, X]</code> is equivalent to just a single <code>X</code> requirement, and that <code>And[And[X, Y], And[Y, X]]</code> is also equivalent to <code>And[X, Y]</code>.</p>
<h2 id="and-combinators"><a class="header" href="#and-combinators"><code>And*</code> Combinators.</a></h2>
<p>There are some functions (more will be added as they are found useful) that help you re-arrange <code>And</code>ed effect requirements:</p>
<pre><code class="language-go">// Since `And[A, A]` is equivalent to just `A`.
// Used to collapse Nil requirements just before evaluation.
func AndCollapse(Fx[And[A, A], V]) Fx[A, V]

// Ands S with Nil in the effect requirements
func AndNil(Fx[S, V]) Fx[And[S, Nil], V]

// Swaps A and B. Note: this has no impact on how computation is
// performed, since requirements can be freely re-arranged.
func AndSwap(Fx[And[A, B], V]) Fx[And[B, A], V]


// FlatMaps the inner effect into the outer by 
// Anding their requirements.
func AndJoin(Fx[A, Fx[B, V]]) Fx[And[A, B], V]

// Reverse of Join
func AndDisjoin(Fx[And[A, B], V]) Fx[A, Fx[B, V]]

</code></pre>
<h2 id="provide-combinators"><a class="header" href="#provide-combinators"><code>Provide*</code> Combinators.</a></h2>
<p>These functions are used to provide requirements into effects. The result is another effect (no computation has been performed yet) but with less requirements.</p>
<pre><code class="language-go">// Discharges the single S requirement.
func Provide(Fx[S, V], *S) Fx[Nil, V]


// Discharges the requirement of A by providing it.
func ProvideLeft(Fx[And[A, B], V], *A) Fx[B, V]

// Discharges the requirement of B by providing it.
func ProvideRight(Fx[And[A, B], V], *B) Fx[A, V]

// Discharges both A and B
func ProvideBoth(Fx[And[A, B], V], *A, *B) Fx[Nil, V]



// Provides A, the `CAAR` of the requirements list.
func ProvideA(Fx[And[And[A, C], And[B, D]], V], *A) Fx[And[C, And[B, D]], V]

// Provides B, the `CADR` of the requirements list.
func ProvideB(Fx[And[And[A, C], And[B, D]], V], *B) Fx[And[And[A, C], D], V]

// Provides A and B, the `CAAR` and `CADR` of the requirements list.
func ProvideAB(Fx[And[And[A, C], And[B, D]], V], *A, *B) Fx[And[C, D], V]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="effect-requests"><a class="header" href="#effect-requests">Effect Requests</a></h1>
<p>Another way of creating effects in <code>Fx.go</code> is via an <em>effect-request</em> function.</p>
<p>A function of type <code>func(I) Fx[S, O]</code> is said to take an <em>effect-request</em> <code>I</code> and produce an <em>suspended</em> effect <code>Fx[S, O]</code>.</p>
<p>For example, the function <code>func(HttpReq) Fx[HttpService, HttpRes]</code> states that given an <code>HttpReq</code> request you can obtain an <code>HttpRes</code> response, <em>provided</em> that an <code>HttpService</code> is available.</p>
<p>Using the "length of string" example of the previous chapters, we can use it to model an effect request:</p>
<pre><code class="language-go">type LenFn = func(string) fx.Fx[fx.Nil, int]

// Code is type annotated for clarity
var lenFx fx.Fx[fx.And[LenFn, fx.Nil], int] = fx.Suspend[LenFn]("hello")
</code></pre>
<p>Note that <code>Suspend</code> takes the <em>type</em> of a request-effect function and the request value for it. And yields a <em>suspended</em> effect of type <code>Fx[And[LenFn, Nil], int]</code>. The computation is said to be <em>suspended</em> because it knows not what particular implementation of <code>LenFn</code> should be used, and because of this, <code>LenFn</code> is part of the requirements, along with <code>Nil</code> the ability requirement on the result of <code>LenFn</code>.</p>
<p>Different implementations of <code>LenFn</code> can be provided to the <code>lenFx</code> effect.</p>
<pre><code class="language-go">var bad LenFn = func(_ string) fx.Fx[fx.Nil, int] {
    lies := 42
    return fx.Pure(&amp;lies)
}
var good LenFn = func(s string) fx.Fx[fx.Nil, int] {
    truth := len(s)
    return fx.Pure(&amp;truth)
}

var x *int = fx.Eval(fx.ProvideLeft(lenFx, &amp;bad))
assert(*x == 42)

var y *int = fx.Eval(fx.ProvideLeft(lenFx, &amp;good))
assert(*y == 5)
</code></pre>
<p>Notice that by delaying which implementation of <code>LenFn</code> is used, the <code>lenFx</code> program description includes the effect-request <code>"hello"</code> and knows the general form of its response <code>Fx[Nil, int]</code>, but knows nothing about which particular interpretation of <code>LenFn</code> will be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handlers-1"><a class="header" href="#handlers-1">Handlers</a></h1>
<p>A <em>Handler</em> is an effect transformer function of type <code>func(Fx[R, U]) Fx[S, V]</code>. Handlers are free to change the effect requirements, they tipically reduce the requirement set, but they could also introduce new requirements. Also the result value can be changed or be the same.</p>
<h2 id="handling-an-effect"><a class="header" href="#handling-an-effect">Handling an effect</a></h2>
<p>Lets re-write our previous "length of string" function as a Handler.</p>
<pre><code class="language-go">type LenFn = func(string) fx.Fx[fx.Nil, int]

// Code is type annotated for clarity
var lenFx fx.Fx[fx.And[LenFn, fx.Nil], int] = fx.Suspend[LenFn]("hello")

// type is not needed but just added for clarity.
type LenHn = func(fx.Fx[fx.And[LenFn, fx.Nil], int]) fx.Fx[fx.Nil, int]

var handler LenHn = fx.Handler(func(s string) fx.Fx[fx.Nil, int] {
    truth := len(s)
    return fx.Pure(&amp;truth)
})

// apply the handler to lenFx
var x *int = fx.Eval(handler(lenFx))
assert(*x == 5)
</code></pre>
<p>As you might guess, <code>fx.Handler</code> is just a wrapper for <code>ProvideLeft(Fx[And[Fn, S], O], *Fn) Fx[S, O]</code> where <code>Fn = func(I) Fx[S, O]</code>, an request-effect function.</p>
<h2 id="requesting-handlers-effect-transformers-from-the-environment"><a class="header" href="#requesting-handlers-effect-transformers-from-the-environment">Requesting Handlers (effect-transformers) from the environment.</a></h2>
<p>Of course, you can also request that a particular effect transformer (Handler) be present as a requirement of some computation. In this way the handler is provided only once but can be applied anywhere it is needed inside the program.</p>
<pre><code class="language-go">// Same examples as above with some more types for clarity
type LenFn = func(string) fx.Fx[fx.Nil, int]
type LenFx = fx.Fx[fx.And[LenFn, fx.Nil], int]
type LenHn = func(LenFx) fx.Fx[fx.Nil, int]

var lenFx LenFx = fx.Suspend[LenFn]("hello")

// Request that an implementation of LenHn transformer 
// is available in the environment and it be applied to lenFx.
var lenAp Fx[And[LenHn, Nil], int] = fx.Apply[LenHn](lenFx)

var handler LenHn = fx.Handler(func(s string) fx.Fx[fx.Nil, int] {
    truth := len(s)
    return fx.Pure(&amp;truth)
})

// Now instead of applying the handler directly to each effect it
// must handle, we provide it into the environment.
var provided Fx[Nil, int] = fx.ProvideLeft(lenAp, &amp;handler)
val x *int = fx.Eval(provided)
assert(*x == 5)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-http-reqres-program"><a class="header" href="#example-http-reqres-program">Example HTTP Req/Res program</a></h1>
<p>As an example of the concepts we have seen so far, lets write a program that needs to perform an HTTP Request, expects an HTTP response from the webservice it accesses and then perform some logic on that response.</p>
<p>On an effect system like <code>Fx.go</code>, we <em>do not</em> directly contact external services, we just express our need to perform such requests and we expect a <code>Handler</code> to actually decide how and when such request should be performed (if any).</p>
<pre><code class="language-go">package http_example

// Notice we do not import any HTTP library, just effects.
import (
	"testing"
	fx "github.com/vic/fx.go"
)

// For simplicity our request is just an string: An URL.
type HttpRq string

// For simplicity out response is just an string: The response body.
type HttpRs string

// Type of the request-effect function. This will be implemented
// by some handler to provide actual responses.
//
// fx.Nil in the result type indicates that our Http ability does
// not requires any other ability.
type HttpFn = func(HttpRq) fx.Fx[fx.Nil, HttpRs]

// Type of the Handler (effect transformer) that handles requests.
type HttpHn = func(fx.Fx[fx.And[HttpFn, fx.Nil], HttpRs]) fx.Fx[fx.Nil, HttpRs]

// Type of an effect ability (requires the handler) and additional abilities.
type HttpAb = fx.And[HttpHn, fx.Nil]

// An http effect that produces V
type HttpFx[V any] = fx.Fx[HttpAb, V]

// An effect of HTTP GET requests.
func Get(url HttpRq) HttpFx[HttpRs] {
	// Request[HttpHn](input) is the same as Apply[HttpHn](Suspend[HttpFn](input))
	return fx.Request[HttpHn](url)
}

// A program that computes the respose length of https://example.org
func Program() HttpFx[int] {
	return fx.Map(Get("https://example.org"), func(r HttpRs) int {
		return len(r)
	})
}

func TestProgram(t *testing.T) {
	httpHandler := fx.Handler(func(r HttpRq) fx.Fx[fx.Nil, HttpRs] {
		mock := HttpRs("example")
		return fx.Pure(&amp;mock)
	})
	var provided fx.Fx[fx.Nil, int] = fx.ProvideLeft(Program(), &amp;httpHandler)
	var result *int = fx.Eval(provided)
	if *result != len("example") {
		t.Errorf("Unexpected result %v", *result)
	}
}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
